I"!<h1 id="module--instantiation">Module &amp; Instantiation</h1>

<!--more-->

<p>디지털 회로를 설계할때 하나의 블럭안에 모든회로를 표현하면 매우 복잡합니다. __그림1__의 경우 4bit addition을 하는 간단한 회로임에도 매우 복잡해 보입니다.</p>

<p><img src="https://raw.githubusercontent.com/ParkDongho/ParkDongho.github.io/master/assets/images/2021-12-19-chapter2_module_%26_instantiation/시스템_반도체_설계_2장-figure_1.drawio.png" alt="fig 1" /></p>

<p><strong>그림1</strong> 4bit Adder 예제</p>

<p>그래서 __그림2__와 같이 회로를 여러 서브블럭들로 나누어 설계를 합니다. 이러한 각각의 블럭을 모듈이라고 합니다.  그림2는 full-adder 4개를 연결하여 4bit adder를 만든 예시 입니다.</p>

<p><img src="https://raw.githubusercontent.com/ParkDongho/ParkDongho.github.io/master/assets/images/2021-12-19-chapter2_module_%26_instantiation/시스템_반도체_설계_2장-figure_2.drawio.png" alt="fig 1" /></p>

<p><strong>figure 2</strong> module instantiation의 예시</p>

<h2 id="21-module">2.1 Module</h2>

<p>위에서 모듈이 무었인지 알아보았습니다. 이제 이를 베릴로그에서 어떻게 기술하는지 알아봅시다.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="err">모듈명</span><span class="p">(</span> <span class="c1">//모듈 시작</span>
  <span class="c1">//port를 정의</span>
<span class="p">)</span>
  
  <span class="c1">//내부로직을 정의</span>
  
<span class="k">endmodule</span> <span class="c1">//모듈 끝</span>
</code></pre></div></div>

<p>verilog의 module은<code class="language-plaintext highlighter-rouge">module</code>이라는 키워드로 시작하고 <code class="language-plaintext highlighter-rouge">endmodule</code>이라는 키워드로 모듈을 닫습니다.</p>

<p>이때 <code class="language-plaintext highlighter-rouge">module</code>이라는 키워드 다음에 <code class="language-plaintext highlighter-rouge">모듈명</code>을 정의합니다.</p>

<h3 id="211-port">2.1.1 Port</h3>

<p>모듈이 외부 및 다른 모듈과 신호를 주고 받으려면 입출력 단자가 필요합니다. 이러한 입출력 단자를 <code class="language-plaintext highlighter-rouge">포트</code>라고 합니다. 이러한 입력단자에서 신호를 받아 처리를 한후 출력단자로 내보냅니다. verilog에서는 총 3가지의 port가 있습니다.</p>

<ul>
  <li>input : 모듈내로 데이터를 받는 포트</li>
  <li>output : 모듈밖으로 데이터를 내보내는 포트</li>
  <li>inout : 모듈 내로 데이터를 받을수도 있고 밖으로 데이터를 내보낼 수도 있는 양방향 포트</li>
</ul>

<p>이때 각 포트의 변수타입을 결정하는 규칙이 있습니다. 아래 그림2를 보면</p>

<ul>
  <li>input</li>
  <li>output</li>
  <li>inout</li>
</ul>

<p><img src="https://raw.githubusercontent.com/ParkDongho/ParkDongho.github.io/master/assets/images/2021-12-19-chapter2_module_%26_instantiation/시스템_반도체_설계_2장-figure_4.drawio.png" alt="figure4" /></p>

<p><strong>figure 2</strong> module의 포트 연결 규칙</p>

<p>왜 이런 규칙이 존재하는지 생각해 볼까요? 이 부분은 베릴로그가 처음이신 분은 넘어가도 괜찮습니다.</p>

<p>먼저 모듈의 입력은 반드시 continuous하게 신호를 받아야 된다는 규칙이 있습니다. 이렇게 continuous하게 들어온 신호에 의하여 내부로직이 continuous(assign문)하게 혹은 procedual(always문)하게 연산된후 출력을 내보내게되죠. 따라서 출력은 continuous 혹은 procedual할 수 있습니다. 이때 continuous한 신호는 wire에 procedual한 신호는 reg타입에 대응됩니다.</p>

<p><img src="https://raw.githubusercontent.com/ParkDongho/ParkDongho.github.io/master/assets/images/2021-12-19-chapter2_module_%26_instantiation/시스템_반도체_설계_2장-figure_5.drawio.png" alt="figure5" /></p>

<p><strong>figure 3</strong> module의 포트 연결 규칙 with instantiation</p>

<p>모듈A를 instantiation한 모듈B를 가정해 봅시다. 모듈 B의 입장에서 모듈 A의 출력포트에 연결된 신호는 모듈B의 input입니다. input은 반드시 continuous 하여야 하므로 net 타입만이 올 수 있습니다. 이와 동일하게 모듈 B의 입장에서 모듈 A의 입력 포트에 연결된 신호는 모듈B의 output입니다. 따라서 reg 혹은 net타입이 올 수 있죠.</p>

<p>이제 포트를 어떻게 표현할 수 있는지 알아 봅시다.</p>

<p>포트는 아래와 같이</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="err">모듈명</span><span class="p">(</span>
  <span class="o">&lt;</span><span class="err">포트</span><span class="mi">_</span><span class="err">타입</span><span class="o">&gt;</span> <span class="p">[</span><span class="err">변수</span><span class="mi">_</span><span class="err">타입</span><span class="p">]</span> <span class="err">입력</span><span class="mi">_</span><span class="err">포트</span><span class="mi">_</span><span class="err">명</span>
  <span class="o">&lt;</span><span class="err">포트</span><span class="mi">_</span><span class="err">타입</span><span class="o">&gt;</span> <span class="p">[</span><span class="err">변수</span><span class="mi">_</span><span class="err">타입</span><span class="p">]</span> <span class="err">입력</span><span class="mi">_</span><span class="err">포트</span><span class="mi">_</span><span class="err">명</span>
<span class="p">);</span>
  
  <span class="c1">//여기에 내부 로직 기술</span>
  
<span class="k">endmodule</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;포트_타입&gt; [변수_타입] 입력_포트_명</code> 와 같은 형태로 표현 할 수 있습니다.</p>

<p>이때</p>

<p><code class="language-plaintext highlighter-rouge">&lt;포트_타입&gt;</code> 은  <code class="language-plaintext highlighter-rouge">input</code>, <code class="language-plaintext highlighter-rouge">output</code>, <code class="language-plaintext highlighter-rouge">inout</code>이 올 수 있고 반드시 정의 해야 합니다.</p>

<p><code class="language-plaintext highlighter-rouge">[변수_타입]</code>은 <code class="language-plaintext highlighter-rouge">wire</code>, <code class="language-plaintext highlighter-rouge">reg</code>가 올수 있으며 생략가능합니다. 만약 생략하였을시 기본적으로 <code class="language-plaintext highlighter-rouge">wire</code>가 오게 됩니다. 만약 출력값을 유지시켜줄 필요가 있다면 <code class="language-plaintext highlighter-rouge">reg</code>를 사용할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">입력_포트_명</code>은 포트의 이름을 정의 해줍니다.</p>

<p>예제를 통해 확인해 봅시다.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">ex_2_01_mux_2_to_1</span><span class="p">(</span> <span class="c1">//module 키워드로 모듈시작</span>
  <span class="kt">input</span> <span class="n">A</span><span class="p">,</span>      <span class="c1">//1bit wire input</span>
  <span class="kt">input</span> <span class="kt">wire</span> <span class="n">B</span><span class="p">,</span> <span class="c1">//1bit wire input</span>
  <span class="kt">input</span> <span class="kt">wire</span> <span class="n">S</span><span class="p">,</span> <span class="c1">//1bit wire input</span>
  
  <span class="kt">output</span> <span class="kt">reg</span> <span class="n">Z</span>  <span class="c1">//1bit reg output</span>
<span class="p">);</span>
  
  <span class="c1">//mux의 내부 로직</span>
  
<span class="k">endmodule</span> <span class="c1">//endmodule 키워드로 모듈 종료</span>
</code></pre></div></div>

<p><strong>Example 2.1</strong></p>

<ul>
  <li>
    <p>모듈의 이름은 ex_2_01_mux_2_to_1입니다.</p>
  </li>
  <li>input 포트 A는 변수 타입을 생략하였으므로 wire 타입입니다.</li>
  <li>input 포트 B 및 S는 wire로 변수 타입이 선언 되었습니다.</li>
  <li>output 포트 Z는 reg 타입으로 선언되었습니다.</li>
</ul>

<h3 id="212-vector-form">2.1.2 Vector Form</h3>

<h2 id="22-instantiation">2.2 Instantiation</h2>

:ET